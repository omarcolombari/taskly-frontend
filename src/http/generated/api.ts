/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * Tasks API
 * API para gerenciamento de tarefas
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { http } from '../client'
export interface AuthenticateBodyDto {
  email: string
  password: string
}

export interface AuthenticateResponseDto {
  access_token: string
}

export interface CreateAccountBodyDto {
  name: string
  email: string
  password: string
}

export interface CreateTaskBodyDto {
  name: string
  description: string
}

export interface EditTaskBodyDto {
  name: string
  description: string
}

export type ListTasksResponseDtoTasksItem = {
  id: string
  name: string
  description: string
  status: string
  completedAt: string
  createdAt: string
  updatedAt: string
}

export interface ListTasksResponseDto {
  tasks: ListTasksResponseDtoTasksItem[]
}

export type GetProfileInformationResponseDtoUser = {
  name: string
  email: string
}

export interface GetProfileInformationResponseDto {
  user: GetProfileInformationResponseDtoUser
}

export type ListTasksParams = {
  status: string
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

export const getSignInUrl = () => {
  return `/sessions`
}

export const signIn = async (
  authenticateBodyDto: AuthenticateBodyDto,
  options?: RequestInit
): Promise<AuthenticateResponseDto> => {
  return http<AuthenticateResponseDto>(getSignInUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(authenticateBodyDto),
  })
}

export const getSignInMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signIn>>,
    TError,
    { data: AuthenticateBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof signIn>>,
  TError,
  { data: AuthenticateBodyDto },
  TContext
> => {
  const mutationKey = ['signIn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signIn>>,
    { data: AuthenticateBodyDto }
  > = props => {
    const { data } = props ?? {}

    return signIn(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SignInMutationResult = NonNullable<
  Awaited<ReturnType<typeof signIn>>
>
export type SignInMutationBody = AuthenticateBodyDto
export type SignInMutationError = unknown

export const useSignIn = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signIn>>,
    TError,
    { data: AuthenticateBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof signIn>>,
  TError,
  { data: AuthenticateBodyDto },
  TContext
> => {
  const mutationOptions = getSignInMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getSignUpUrl = () => {
  return `/accounts`
}

export const signUp = async (
  createAccountBodyDto: CreateAccountBodyDto,
  options?: RequestInit
): Promise<void> => {
  return http<void>(getSignUpUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createAccountBodyDto),
  })
}

export const getSignUpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUp>>,
    TError,
    { data: CreateAccountBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUp>>,
  TError,
  { data: CreateAccountBodyDto },
  TContext
> => {
  const mutationKey = ['signUp']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signUp>>,
    { data: CreateAccountBodyDto }
  > = props => {
    const { data } = props ?? {}

    return signUp(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SignUpMutationResult = NonNullable<
  Awaited<ReturnType<typeof signUp>>
>
export type SignUpMutationBody = CreateAccountBodyDto
export type SignUpMutationError = unknown

export const useSignUp = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUp>>,
    TError,
    { data: CreateAccountBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof signUp>>,
  TError,
  { data: CreateAccountBodyDto },
  TContext
> => {
  const mutationOptions = getSignUpMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getCreateTaskUrl = () => {
  return `/tasks`
}

export const createTask = async (
  createTaskBodyDto: CreateTaskBodyDto,
  options?: RequestInit
): Promise<void> => {
  return http<void>(getCreateTaskUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createTaskBodyDto),
  })
}

export const getCreateTaskMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTask>>,
    TError,
    { data: CreateTaskBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTask>>,
  TError,
  { data: CreateTaskBodyDto },
  TContext
> => {
  const mutationKey = ['createTask']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTask>>,
    { data: CreateTaskBodyDto }
  > = props => {
    const { data } = props ?? {}

    return createTask(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTask>>
>
export type CreateTaskMutationBody = CreateTaskBodyDto
export type CreateTaskMutationError = unknown

export const useCreateTask = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTask>>,
    TError,
    { data: CreateTaskBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof createTask>>,
  TError,
  { data: CreateTaskBodyDto },
  TContext
> => {
  const mutationOptions = getCreateTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getListTasksUrl = (params: ListTasksParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/tasks?${stringifiedParams}` : `/tasks`
}

export const listTasks = async (
  params: ListTasksParams,
  options?: RequestInit
): Promise<ListTasksResponseDto> => {
  return http<ListTasksResponseDto>(getListTasksUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListTasksQueryKey = (params?: ListTasksParams) => {
  return [`/tasks`, ...(params ? [params] : [])] as const
}

export const getListTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  params: ListTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>
    >
    request?: SecondParameter<typeof http>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListTasksQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listTasks>>> = ({
    signal,
  }) => listTasks(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof listTasks>>
>
export type ListTasksQueryError = unknown

export function useListTasks<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  params: ListTasksParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasks>>,
          TError,
          Awaited<ReturnType<typeof listTasks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof http>
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListTasks<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  params: ListTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasks>>,
          TError,
          Awaited<ReturnType<typeof listTasks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof http>
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListTasks<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  params: ListTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>
    >
    request?: SecondParameter<typeof http>
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useListTasks<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  params: ListTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>
    >
    request?: SecondParameter<typeof http>
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListTasksQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getEditTaskUrl = (id: string) => {
  return `/tasks/${id}`
}

export const editTask = async (
  id: string,
  editTaskBodyDto: EditTaskBodyDto,
  options?: RequestInit
): Promise<void> => {
  return http<void>(getEditTaskUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(editTaskBodyDto),
  })
}

export const getEditTaskMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof editTask>>,
    TError,
    { id: string; data: EditTaskBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof editTask>>,
  TError,
  { id: string; data: EditTaskBodyDto },
  TContext
> => {
  const mutationKey = ['editTask']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof editTask>>,
    { id: string; data: EditTaskBodyDto }
  > = props => {
    const { id, data } = props ?? {}

    return editTask(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EditTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof editTask>>
>
export type EditTaskMutationBody = EditTaskBodyDto
export type EditTaskMutationError = unknown

export const useEditTask = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof editTask>>,
    TError,
    { id: string; data: EditTaskBodyDto },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof editTask>>,
  TError,
  { id: string; data: EditTaskBodyDto },
  TContext
> => {
  const mutationOptions = getEditTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getDeleteTaskUrl = (id: string) => {
  return `/tasks/${id}`
}

export const deleteTask = async (
  id: string,
  options?: RequestInit
): Promise<void> => {
  return http<void>(getDeleteTaskUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteTaskMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTask>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteTask']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTask>>,
    { id: string }
  > = props => {
    const { id } = props ?? {}

    return deleteTask(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTask>>
>

export type DeleteTaskMutationError = unknown

export const useDeleteTask = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTask>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getCompleteTaskUrl = (id: string) => {
  return `/tasks/${id}/complete`
}

export const completeTask = async (
  id: string,
  options?: RequestInit
): Promise<void> => {
  return http<void>(getCompleteTaskUrl(id), {
    ...options,
    method: 'PATCH',
  })
}

export const getCompleteTaskMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeTask>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationOptions<
  Awaited<ReturnType<typeof completeTask>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['completeTask']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completeTask>>,
    { id: string }
  > = props => {
    const { id } = props ?? {}

    return completeTask(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CompleteTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof completeTask>>
>

export type CompleteTaskMutationError = unknown

export const useCompleteTask = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeTask>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof http>
}): UseMutationResult<
  Awaited<ReturnType<typeof completeTask>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getCompleteTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

export const getGetProfileInformationUrl = () => {
  return `/profile`
}

export const getProfileInformation = async (
  options?: RequestInit
): Promise<GetProfileInformationResponseDto> => {
  return http<GetProfileInformationResponseDto>(getGetProfileInformationUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetProfileInformationQueryKey = () => {
  return [`/profile`] as const
}

export const getGetProfileInformationQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfileInformation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getProfileInformation>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof http>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProfileInformationQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProfileInformation>>
  > = ({ signal }) => getProfileInformation({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfileInformation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileInformationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfileInformation>>
>
export type GetProfileInformationQueryError = unknown

export function useGetProfileInformation<
  TData = Awaited<ReturnType<typeof getProfileInformation>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getProfileInformation>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getProfileInformation>>,
        TError,
        Awaited<ReturnType<typeof getProfileInformation>>
      >,
      'initialData'
    >
  request?: SecondParameter<typeof http>
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfileInformation<
  TData = Awaited<ReturnType<typeof getProfileInformation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getProfileInformation>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getProfileInformation>>,
        TError,
        Awaited<ReturnType<typeof getProfileInformation>>
      >,
      'initialData'
    >
  request?: SecondParameter<typeof http>
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfileInformation<
  TData = Awaited<ReturnType<typeof getProfileInformation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getProfileInformation>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof http>
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useGetProfileInformation<
  TData = Awaited<ReturnType<typeof getProfileInformation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getProfileInformation>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof http>
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProfileInformationQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
